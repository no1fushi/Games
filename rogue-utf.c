//以下実装済みには!!をつける

/*Rougue -ローグ-
1980年に初版が発表されており、最初期のコンピュータRPGの一つ
いわゆるローグライクゲーム(風来のシレン,トルネコの大冒険 等)の元となったゲーム

ローグの要素PDL
Procedual(自動生成)
・環境の自動(ランダム)生成
・アイテムやモンスターその他コンテンツ
Death(死)
・死亡すると最初のレベルからやりなおし
・プレイヤーの状態,HP等の数字を表示
Labyrinth(迷宮)
・部屋と廊下で構成される
・行列でのマス目


その他
・ターン制
・敵とプレイヤーは同じルール(特性,法則)を持っている
例:魔法を使える,アイテムを使える
*/

/*
仕様
confファイルを用意
・mapや強さの設定
・キー配列(vi,十字,WASD)


ステータス
HP
ATTACK
GARD
EAT
DRINK
GORD

マップに使われる文字
=壁
#通路
+扉
.何もない床
%階段
^罠

@主人公
A‾Zモンスター


*お金
:食料
)武器
]防具
!飲み物
?巻物
/その他

コマンド
?ヘルプ
Sセーブ
!破棄
i所持品一覧
m物を拾う
dアイテムを判別する
cアイテムに名前をつける
d所持品を落とす
t所持品を投げる
e食べる
n飲む
w装備する
h装備をはずす
移動(vi,wasdm十字)
s探す
.休憩
^罠を調べる
>階段を上る
<階段を下りる
*/

/*ToDo
・ランダムマップ生成
*/

/*ストーリーと目的
あなたは戦士ギルドから数年にわたる戦闘訓練を受けた。
これから、ギルドの一員となるにあたり、ギルドはあなたに一つの課題を与えた
その課題は
運命の洞窟に入りその奥深くにある「イェンダーの魔除け」を取って来るというものだ
成功の暁にはあなたはギルドの正式メンバーとされる上、洞窟から持ち帰ったすべての財宝は自分の財産にできる

目的:
迷宮で拾った金貨でスコアが決まりそのスコアを競う(,アイテム,到達進度,レベルはスコアに影響しない)
イェンダーの魔除けを手に入れゲームをクリアすると所持品のすべてが金額に換算されスコアとなるが
基本的にイェンダーの魔除けを手に入れるのは超高難易度で不可能に近い

同じ所持金でも死亡時と中断時でスコアが異なり
死亡時:所持金の10%が遺体を家族の下に運ぶ手間賃として回収されスコアは90%となる
中断時:所持金の100%がスコアとなる
*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define FROAR_Y 25 //後で使うかも
#define FROAR_X 80 //後で使うかもん
#define MIN_MAP   5  //mapの最小サイズ
#define MAX_TMAP 15 //mapの縦最大サイズ
#define MAX_YMAP 25 //mapの横最大サイズ

int conf_r(){

	return(0)
}

int conf_w(){
	return(0)	
}

int cls(){

	char s = NULL;

	printf("ENTERを押してください");
	scanf("%c",&s);
	if(s != NULL) system("clear");

	return(0);
}

int story(){
	puts("-*-*-*-*ストーリー*-*-*-*-");
	puts("");
	puts("あなたは高専ギルドから数年にわたる戦闘訓練を受けた");
	puts("これから、ギルドの一員となるにあたり、ギルドはあなたに一つの課題を与えた");
	puts("その課題は、運命の洞窟に入りその奥深くにある「クシローネの守り」を取って来るというものだ");
	puts("成功の暁にはあなたはギルドの正式メンバーとされる上、洞窟から持ち帰ったすべての財宝は自分の財産にできる");
	puts("");
	puts("-*-*-*-*基本ルール*-*-*-*-");
	puts("洞窟で拾った金貨(GOLD)でスコアが決まりそのスコアを競う(アイテム,到達進度,レベルはスコアに影響しない)");
	puts("「クシローネの守り」をを手に入れゲームをクリアすると所持品のすべてが金額に換算されスコアとなるが");
	puts("ただし基本的に「クシローネの守り」を手に入れるのは超高難易度で不可能に近い");
	puts("");
	puts("同じ所持金でも死亡時と中断時でスコアが異なり");
	puts("死亡時:所持金の10%が遺体を家族の下に運ぶ手間賃として回収されスコアは90%となる");
	puts("中断時:所持金の100%がスコアとなる");
	
	printf("ここまで理解できたなら");
	cls();

	return(0);
}

//キャラクタの初期位置を決める
int* posi_f(int n,int m){

	int *posi[2]
	
	while(1){
		posi[0] = 1 + rand() % (n - 1);
		posi[1] = 1 + rand() % (m - 1);

		if(posi[0] != 0 && posi[1] != 0 && posi[])
	}

	return(posi);
}

//ランダムなマップを作る
char** create_map(){

	char **matrix, *matrix_b; //二次元配列用ポインタ
	int n, m;  // 配列の要素数
	int i,j;  // for文用

	n = MIN_MAP + rand() % (MAX_TMAP - MIN_MAP);
	m = MIN_MAP + rand() % (MAX_YMAP - MIN_MAP);

	//配列要素の動的確保
	matrix = (char**)malloc(sizeof(int *) * n);
	matrix_b = (char*)malloc(sizeof(int *) * n * m);
	for(i = 0; i < n; i++) matrix[i] = matrix_b + i * m;

	//マップ生成
	for(i = 0;i < n;i++){
		for(j = 0;j < m;j++){
			if(i == 0 || i == n-1 || j == 0 || j == m-1){
				matrix[i][j] =  '#';
			}else{
				matrix[i][j] = '0';
			}
		}
		puts("");
	}

	return(matrix);
	
	// メモリ開放
	free(matrix_b);
	free(matrix);
}

int main(void){
	
	srand((unsigned int)time(NULL));
	char **map = create_map();
	int i, j;

	story();

	return(0);
}

